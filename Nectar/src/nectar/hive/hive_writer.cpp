#include <nectar/hive/hive_writer.h>
#include <wax/containers/vector.h>

namespace nectar
{
    namespace
    {
        void WriteValue(const HiveValue& value, wax::String<>& out)
        {
            switch (value.type)
            {
                case HiveValue::Type::String:
                    out.Append('"');
                    // Escape special characters
                    for (size_t i = 0; i < value.str.Size(); ++i)
                    {
                        char c = value.str[i];
                        switch (c)
                        {
                            case '"':  out.Append("\\\"", 2); break;
                            case '\\': out.Append("\\\\", 2); break;
                            case '\n': out.Append("\\n", 2); break;
                            case '\t': out.Append("\\t", 2); break;
                            default:   out.Append(c); break;
                        }
                    }
                    out.Append('"');
                    break;

                case HiveValue::Type::Bool:
                    out.Append(value.bool_val ? "true" : "false");
                    break;

                case HiveValue::Type::Int:
                {
                    char buf[32];
                    int len = std::snprintf(buf, sizeof(buf), "%lld", static_cast<long long>(value.int_val));
                    out.Append(buf, static_cast<size_t>(len));
                    break;
                }

                case HiveValue::Type::Float:
                {
                    char buf[64];
                    int len = std::snprintf(buf, sizeof(buf), "%g", value.float_val);
                    out.Append(buf, static_cast<size_t>(len));
                    break;
                }

                case HiveValue::Type::StringArray:
                    out.Append('[');
                    for (size_t i = 0; i < value.array.Size(); ++i)
                    {
                        if (i > 0) out.Append(", ", 2);
                        out.Append('"');
                        for (size_t j = 0; j < value.array[i].Size(); ++j)
                        {
                            char c = value.array[i][j];
                            switch (c)
                            {
                                case '"':  out.Append("\\\"", 2); break;
                                case '\\': out.Append("\\\\", 2); break;
                                default:   out.Append(c); break;
                            }
                        }
                        out.Append('"');
                    }
                    out.Append(']');
                    break;
            }
        }
    }

    wax::String<> HiveWriter::Write(const HiveDocument& doc, comb::DefaultAllocator& alloc)
    {
        wax::String<> out{alloc};
        out.Append("# Auto-generated by Nectar\n");

        // Collect and sort section names for deterministic output
        wax::Vector<wax::StringView> section_names{alloc};
        for (auto it = doc.Sections().begin(); it != doc.Sections().end(); ++it)
        {
            section_names.PushBack(it.Key().View());
        }

        // Simple insertion sort (small number of sections)
        for (size_t i = 1; i < section_names.Size(); ++i)
        {
            auto key = section_names[i];
            size_t j = i;
            while (j > 0 && section_names[j - 1].Compare(key) > 0)
            {
                section_names[j] = section_names[j - 1];
                --j;
            }
            section_names[j] = key;
        }

        for (size_t s = 0; s < section_names.Size(); ++s)
        {
            if (s > 0 || out.Size() > 0) out.Append('\n');

            out.Append('[');
            out.Append(section_names[s].Data(), section_names[s].Size());
            out.Append("]\n", 2);

            // Find the section
            wax::String<> sec_key{alloc, section_names[s]};
            auto* section = doc.Sections().Find(sec_key);
            if (!section) continue;

            // Collect and sort keys for deterministic output
            wax::Vector<wax::StringView> keys{alloc};
            for (auto it = section->begin(); it != section->end(); ++it)
            {
                keys.PushBack(it.Key().View());
            }

            for (size_t i = 1; i < keys.Size(); ++i)
            {
                auto key = keys[i];
                size_t j = i;
                while (j > 0 && keys[j - 1].Compare(key) > 0)
                {
                    keys[j] = keys[j - 1];
                    --j;
                }
                keys[j] = key;
            }

            for (size_t k = 0; k < keys.Size(); ++k)
            {
                out.Append(keys[k].Data(), keys[k].Size());
                out.Append(" = ", 3);

                wax::String<> val_key{alloc, keys[k]};
                auto* value = section->Find(val_key);
                if (value)
                {
                    WriteValue(*value, out);
                }
                out.Append('\n');
            }
        }

        return out;
    }
}
